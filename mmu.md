### 内存管理单元 (MMU)

内存管理单元 (MMU) 的一个重要功能是使您能够将任务作为独立的程序运行，每个程序在其自己的私有虚拟内存空间中执行。虚拟内存系统的一个关键特性是地址重定位，即将处理器发出的虚拟地址转换为主存中的物理地址。

ARM 的 MMU 负责将代码和数据的地址从虚拟内存视图翻译为实际系统中的物理地址。这种转换由 MMU 硬件执行，对应用程序是完全透明的。此外，MMU 还控制内存访问权限、内存排序以及每个内存区域的缓存策略等。

在多任务嵌入式系统中，我们通常需要一种方法来划分内存映射，并为这些内存区域分配权限和内存属性。而在运行复杂操作系统（如 Linux）的情况下，我们需要对内存系统进行更精细的控制。

MMU 使任务或应用程序的编写方式无需了解系统的物理内存映射，也无需关心可能同时运行的其他程序。它允许您为每个程序使用相同的虚拟内存地址空间。即使物理内存是碎片化的，您依然可以使用连续的虚拟内存映射。这种虚拟地址空间与系统中的实际物理内存映射是分开的。应用程序是在虚拟内存空间中编写、编译和链接的。虚拟地址是您以及编译器和链接器在将代码放入内存时使用的地址；而物理地址则是实际硬件系统使用的地址。

操作系统的职责是对 MMU 进行编程，使其能够在这两种内存视图之间进行翻译。图 9-1（见第 9-2 页）展示了一个系统示例，说明了内存的虚拟视图和物理视图。在单个系统中，不同的处理器和/或设备可能具有不同的虚拟和物理地址映射，例如某些多核板卡和 PCI 设备。
![[Pasted image 20241031232320.png]]

当 MMU 被禁用时，所有虚拟地址会直接映射到对应的物理地址（即平坦映射）。如果 MMU 无法翻译某个地址，它会在处理器上生成中止异常，并向处理器提供有关问题的详细信息。此功能可以用于按需映射内存或设备，一次映射一页。

### 9.1 虚拟内存

MMU 使您能够构建具有多个虚拟地址映射的系统。每个任务都可以拥有自己的虚拟内存映射。操作系统内核将每个应用程序的代码和数据放置在物理内存中，但应用程序本身并不需要了解这些位置。

MMU 通过使用翻译表来完成地址转换。这些翻译表是软件在内存中创建的树状表结构，MMU 硬件通过遍历这些表来完成虚拟地址的翻译。

#### 注意
在 ARM 架构中，通用计算机术语中的“页表”具有更为具体的含义。ARM 架构使用多级页表，并将翻译表定义为所有这些结构的通用术语。翻译表中的每一项都包含将虚拟内存中的一页翻译为物理内存中的一页所需的全部信息。遍历机制和表格格式是由软件配置的，稍后将进行解释。

翻译表条目按照虚拟地址组织。除了描述该虚拟页到物理页的转换，它们还提供了该页所需的访问权限和内存属性。

![[Pasted image 20241031232338.png]]

由核心生成的地址是虚拟地址。当启用 MMU 时，核心进行的所有内存访问都会通过 MMU。MMU 的基本原理是将虚拟地址的最高有效位替换为其他值，以生成物理地址（实际上定义了一块内存的基地址）。相同的翻译表用于定义指令获取和数据访问所需的翻译和内存属性。

MMU 内的专用硬件使其能够读取内存中的翻译表。这一过程称为“翻译表遍历”。

### 9.1.1 配置和启用 MMU

在启用 MMU 之前，必须将翻译表写入内存，并设置 TTBR 寄存器以指向这些表。然后可以使用以下代码序列来启用 MMU：

```assembly
MRC p15, 0, R1, c1, C0, 0  ; 读取控制寄存器  
ORR R1, #0x1               ; 设置 M 位  
MCR p15, 0, R1, C1, C0, 0  ; 写入控制寄存器并启用 MMU  
```

如果启用 MMU 会改变当前执行代码的区域的地址映射，则必须非常小心。可能需要使用内存屏障（参见第 10-6 页的内存屏障）以确保正确的操作。

### 9.2 翻译旁路缓冲区 (TLB)

翻译旁路缓冲区 (TLB) 是 MMU 中最近执行的页翻译的缓存。在内存访问时，MMU 首先检查 TLB 中是否缓存了该地址的翻译。如果请求的翻译存在于 TLB 中，则称为 TLB 命中，并且 TLB 会立即提供该物理地址的翻译。如果 TLB 中没有该地址的有效翻译，则称为 TLB 未命中，需要进行外部翻译表遍历。此时，新加载的翻译可以缓存到 TLB 中，以供后续使用。

TLB 的具体结构在不同的 ARM 处理器实现中有所不同。以下描述的是一个典型系统的结构，但各个实现可能有所差异。通常，微型 TLB（micro-TLB）位于指令缓存和数据缓存附近。对于那些在微型 TLB 中命中的地址，既不需要额外的内存查找，也不会产生额外的周期开销。然而，微型 TLB 仅能存储少量映射，通常在指令侧和数据侧各存储 8 个条目。微型 TLB 后备的是一个更大的主 TLB（通常有 64 个条目），但如果微型 TLB 未命中而主 TLB 命中，可能会有一定的性能损失。图 9-3 显示了每个 TLB 条目包含物理地址和虚拟地址，以及一些属性（如内存类型、缓存策略和访问权限），还可能包含地址空间标识符 (ASID)，ASID 的详细内容请参见第 9-17 页的“地址空间 ID”部分。

TLB 类似于其他缓存，因此具有 TLB 线替换策略，但这一过程对用户来说是透明的。如果翻译表条目是有效的，虚拟地址、物理地址以及该页或段的其他属性会作为 TLB 条目存储。如果翻译表条目无效，TLB 将不会更新。ARM 架构要求 TLB 仅缓存有效的翻译表描述符。

![[Pasted image 20241031234635.png]]
### 9.2.1 TLB 一致性

当操作系统更改翻译表条目时，TLB 中可能会存在过期的翻译信息。操作系统必须采取措施使 TLB 条目失效。ARM 提供了几种 CP15 指令来实现全局失效 TLB 或删除特定条目。

由于推测性指令获取和数据读取可能会导致翻译表遍历，因此在更改有效的翻译表条目时，必须使 TLB 失效。而无效的翻译表条目不会被缓存到 TLB 中，因此可以在不进行失效操作的情况下直接更改。



Linux 内核提供了一些使用 CP15 操作的函数，包括 `flush_tlb_all()` 和 `flush_tlb_range()`。这些函数通常不需要设备驱动程序调用。

### 9.3 页大小的选择

页大小基本上由操作系统控制，但在选择页大小时值得注意一些相关的考虑。较小的页大小可以更精细地控制内存块的使用，潜在地减少页中的未使用内存。如果一个任务需要 7KB 的数据空间，分配两个 4KB 的页比分配一个 64KB 的页或一个 1MB 的段会减少浪费的空间。较小的页大小还可提供对权限、缓存属性等的更精细控制。

然而，随着页大小的增加，每个 TLB 条目将引用更大的一块内存。因此，在任何访问时更有可能发生 TLB 命中，从而减少了外部内存的翻译表遍历次数，提升性能。基于这种原因，16MB 的超级段可以用于不需要详细映射的大块内存。此外，每个 L2 翻译表需要 1KB 的内存。

### 9.4 一级地址翻译

接下来我们看一下虚拟地址如何通过 ARM 内核的一级翻译表条目被翻译为物理地址。第一步是找到与虚拟地址关联的翻译表条目。

翻译的第一个阶段使用一个一级翻译表，有时称为主翻译表。L1 翻译表将 32 位内核的完整 4GB 地址空间划分为 4096 个大小相等的段，每个段描述 1MB 的虚拟内存空间。因此，L1 翻译表包含 4096 个 32 位（字大小）的条目。

每个条目可以包含指向二级翻译表基地址的指针，也可以是用于翻译 1MB 段的翻译表条目。如果翻译表条目用于翻译 1MB 段（由编码决定，见第 9-8 页的图 9-5），它提供了物理内存中 1MB 页的基地址。

虚拟地址和物理地址的低位部分是相同的（定义了物理内存中相对于基地址的偏移）。ARM MMU 支持多级翻译表架构，包括一级 (L1) 和二级 (L2) 翻译表。除非实现了大物理地址扩展（参见第 22-10 页的大物理地址扩展），否则 L1 和 L2 翻译表使用短描述符翻译表格式，具备以下特点：

- 32 位页描述符。
- 支持最多两级翻译表。
- 支持 32 位物理地址。
- 支持以下内存大小：
  - 16MB 或 1MB 段。
  - 64KB 或 4KB 页大小。

L1 翻译表的基地址称为翻译表基地址，存储在 CP15 c2 中。该地址必须对齐到 16KB 边界。翻译表位置由翻译表基地址寄存器（TTRB0 和 TTRB1）定义。

当 MMU 执行地址翻译时，虚拟地址的高 12 位作为翻译表的索引。
![[Pasted image 20241102211416.png]]

以图 9-4 为例，假设一级翻译表存储在地址 `0x12300000`。处理器发出虚拟地址 `0x00100000`。虚拟地址的高 12 位 `[31:20]` 定义了正在访问的 1MB 虚拟地址空间。在本例中，值为 `0x001`，因此 MMU 必须读取表中的第 1 项。为了获得表中的偏移量，可以将条目编号乘以条目大小：

```
0x001 * 4 字节 = 地址偏移量 0x004
```

MMU 读取物理地址的翻译表条目的地址为：

```
0x12300000 + 0x004 = 0x12300004
```

现在，您有了翻译表条目的位置，可以使用它来确定物理内存地址。
![[Pasted image 20241102211627.png]]

图 9-5 展示了 CP15 c2 中一级翻译表条目的格式。一级翻译表包含一级描述符。一级翻译表条目可以是以下四种类型之一：

- **1MB 段翻译条目**：将 1MB 区域映射到物理地址。
- **指向 L2 翻译表的条目**：允许将 1MB 的内存块细分为多个页。
- **16MB 超级段**：这是 1MB 段条目的特殊类型，使用翻译表中的 16 个条目，但可以减少分配给此区域的 TLB 条目数量。
- **错误条目**：会生成中止异常，这可以是预取中止或数据中止，取决于访问类型。这实际上表明虚拟地址未映射。

条目的最低两位 `[1:0]` 定义该条目是错误条目、翻译表条目还是段条目。位 `[18]` 用于区分普通段和超级段。


超级段是一个 16MB 的内存块，其虚拟和物理基地址必须对齐到 16MB 边界。由于每个一级翻译表条目描述 1MB，因此需要表中 16 个连续且相同的条目来标记一个超级段。选择页大小的原因参见第 9-6 页的说明，解释了为何超级段有时很有用。332

![[Pasted image 20241102211810.png]]

图 9-6 展示了最简单的情况，其中 1MB 段的物理地址直接由一级翻译表中的单个条目生成。

段（或超级段）的翻译表条目包含用于翻译虚拟地址的物理基地址。翻译表条目中还包含许多其他信息，包括访问权限 (AP) 和可缓存 (C) 或可缓冲 (B) 类型，这些将在第 9-14 页的“内存属性”中介绍。在这些情况下，MMU 不需要查看一级表以外的内容。

![[Pasted image 20241102211931.png]]

图 9-7 总结了通过一级翻译表中的段条目翻译地址的过程。

在 1MB 内存段的翻译表条目中，翻译表条目的高 12 位替换虚拟地址的高 12 位，以生成物理地址，如第 9-8 页的图 9-5 所示。

### 9.5 二级翻译表

二级翻译表 (L2 Translation Table) 包含 256 个字大小（4 字节）的条目，需占用 1KB 的内存空间，并且必须对齐到 1KB 边界。每个条目将 4KB 的虚拟内存块翻译为 4KB 的物理内存块。一个翻译表条目可以给出 4KB 或 64KB 页的基地址。

在二级翻译表中，有三种类型的条目，通过条目中最低两位的值进行区分：

- **大页条目**：指向一个 64KB 的页面。值得注意的是，由于每个条目指向 4KB 的地址空间，因此大页条目必须重复 16 次。
- **小页条目**：指向一个 4KB 的页面。
- **错误页条目**：如果访问该条目，会生成中止异常。



与一级翻译表条目类似，二级翻译表条目中包含物理地址以及关于该页的其他信息。类型扩展 (TEX)、可共享 (S) 和访问权限 (AP, APX) 位用于指定 ARMv7 内存模型所需的属性。配合 TEX 位，缓存 (C) 和缓冲 (B) 位控制该翻译表条目管理的内存的缓存策略。nG 位定义该页是否为全局页（适用于所有进程）或非全局页（仅供特定进程使用）。这些属性将在第 9-14 页的“内存属性”部分中详细说明。

```plaintext
15 14 12 11 10 9 8  6  5  4  3  2  1  0
Fault Ignored 0  0
S TEX AP X N C B  (大页条目) 0 1 大页基地址 SBZ
S AP X AP C B  (小页条目) 1 小页基地址 TEX X N A P X nG nG
```



在图 9-9 中，我们看到如何计算所需的二级翻译表条目的地址。首先获取二级翻译表的基地址（由一级翻译表条目提供），该地址对齐到 1KB 边界。然后，使用虚拟地址中的 8 位（位 [19:12]）在二级翻译表的 256 个条目中进行索引。



二级翻译表基地址（1KB 对齐）由 L1 翻译表条目提供。虚拟地址的 [19:12] 位用作索引，定位二级翻译表中的相应条目。



图 9-10 总结了使用两级翻译表时的地址翻译过程。虚拟地址的 [31:20] 位用于索引 4096 项的一级翻译表，该表的基地址由 CP15 TTB 寄存器提供。L1 翻译表条目指向包含 256 项的二级翻译表。虚拟地址的 [19:12] 位用于选择其中的一个条目，该条目提供页的基地址。然后，将该基地址与虚拟地址的剩余位组合，生成最终的物理地址。

### 9.6 内存属性

我们已经了解了翻译表条目如何使 MMU 硬件将虚拟地址翻译为物理地址。然而，翻译表条目还指定了与每个页相关的多个属性，包括访问权限、内存类型和缓存策略。

#### 9.6.1 内存访问权限

翻译表条目中的访问权限位 (AP 和 APX) 用于指定页面的访问权限，如表 9-1 所示。

如果访问没有所需的权限（或发生错误），将导致中止。在数据访问时，这将导致精确的数据中止异常。在指令获取时，该访问将被标记为中止，如果在执行之前没有将指令刷新，则会触发预取中止异常。通常情况下，由外部访问生成的错误不会是精确的。

有关出错位置的地址和错误原因的信息存储在 CP15 的故障地址和故障状态寄存器中。中止处理程序可以采取适当的措施，例如修改翻译表以解决问题，然后返回应用程序重试访问。或者，如果生成中止的应用程序本身有问题，则必须终止该应用程序。

##### 表 9-1 访问权限编码汇总

| APX | AP  | 特权模式 | 非特权模式 | 描述           |
|-----|-----|----------|------------|----------------|
| 0   | 00  | 无访问   | 无访问     | 访问权限错误   |
| 0   | 01  | 读/写    | 无访问     | 仅特权访问     |
| 0   | 10  | 读/写    | 只读       | 用户模式下禁止写入|
| 0   | 11  | 读/写    | 读/写      | 完全访问       |
| 1   | 00  | --       | --         | 保留           |
| 1   | 01  | 只读     | 无访问     | 特权模式下只读 |
| 1   | 10  | 只读     | 只读       | 只读           |
| 1   | 11  | --       | --         | 保留           |

#### 9.6.2 内存类型

早期的 ARM 架构版本允许通过配置页面是否可以使用缓存和写缓冲区来指定内存访问行为。这种简单的方案对于如今更复杂的系统和处理器已经不够用。在现代系统中，可能会有多个级别的缓存、在多个共享内存的处理器之间进行硬件管理的缓存一致性，以及处理器可能会推测性地获取指令和数据。为满足这些需求，在 ARMv6 中引入了新的内存类型，并在 ARMv7 架构中进一步扩展。

ARM 架构定义了三种互斥的内存类型。所有内存区域都配置为以下三种类型之一：

- **强序内存 (Strongly-ordered)**
- **设备内存 (Device)**
- **普通内存 (Normal)**

##### 表 9-2 内存属性汇总

| 内存类型           | 可共享性 | 可缓存性 | 描述                                             |
|--------------------|----------|----------|--------------------------------------------------|
| 普通内存（可共享） | 是       | 是       | 设计用于多个核心共享的普通内存。                 |
| 普通内存（不可共享）| 否       | 是       | 设计用于单个核心使用的普通内存。                 |
| 设备内存           | 否       | 否       | 设计用于内存映射外设。所有设备内存访问按程序顺序进行。|
| 强序内存           | 否       | 否       | 所有强序内存的访问按程序顺序进行。所有强序访问被认为是共享的。|

##### 表 9-3 翻译表条目中的内存类型和缓存属性编码

| TEX  | C  | B  | 描述                | 内存类型          |
|------|----|----|---------------------|-------------------|
| 000  | 0  | 0  | 强序                | 强序内存          |
| 000  | 0  | 1  | 可共享设备          | 设备内存          |
| 000  | 1  | 0  | 外部和内部写通，写不分配 | 普通内存          |
| 000  | 1  | 1  | 外部和内部写回，写不分配 | 普通内存          |
| 001  | 0  | 0  | 外部和内部不可缓存  | 普通内存          |
| 001  | -- | -- | 保留                | --                |
| 010  | 0  | 0  | 不可共享设备        | 设备内存          |
| 010  | -- | -- | 保留                | --                |
| 011  | -- | -- | 保留                | --                |
| 1XX  | Y  | Y  | 缓存内存            | 普通内存          |

对于普通的可缓存内存，TEX 字段的最低两位用于提供外部缓存策略（可能用于 L2 或 L3 缓存），而 C 和 B 位用于提供内部缓存策略（适用于 L1 缓存和其他内部缓存）。这使得可以为内部和外部缓存指定不同的缓存策略。

对于 Cortex-A15 和 Cortex-A8 处理器，翻译表条目中设置的内部缓存属性适用于 L1 和 L2 缓存。而在一些较老的处理器上，外部缓存可能支持写分配，而 L1 缓存不支持。当然，这些处理器在运行请求此缓存策略的代码时，仍必须表现正常。

#### 9.6.3 执行禁止 (Execute Never)

当设置翻译表条目中的执行禁止 (XN) 位时，禁止从指定的内存位置进行推测性指令获取。如果尝试从该内存位置执行指令，将触发预取中止异常。通常，将设备内存区域标记为“执行禁止”，以防止意外执行这些位置的代码，并防止推测性指令获取可能引发的不良副作用。

#### 9.6.4 域 (Domains)

ARM 架构有一个独特的特性，允许为内存区域分配域 ID。硬件提供了 16 个域 ID，CP15 c3 包含域访问控制寄存器 (DACR)，该寄存器为每个域编号存储一组 2 位的权限。这使得可以将每个域标记为无访问、管理模式或客户端模式。

- **无访问**：对该域中的任何页面的访问都会中止，无论页面权限如何。
- **管理模式**：忽略所有页面权限，允许完全访问。
- **客户端模式**：使用页面的权限。

##### 注意：

在 ARMv7 架构中，域的使用已被弃用，并将在未来移除。然而，为了强制执行访问权限，仍然需要为一个段分配域号，并确保该域的权限位设置为客户端模式。通常，所有域 ID 字段会设置为 0，并将 DACR 中的所有字段设置为“客户端模式”。

### 9.7 多任务处理与操作系统对翻译表的使用

在大多数使用 Cortex-A 系列处理器的系统中，通常会有多个应用程序或任务同时运行。每个任务都可以在物理内存中拥有自己独特的翻译表。通常，很多内存系统被组织为虚拟到物理地址映射是固定的，翻译表条目不会改变。这通常用于存储操作系统代码和数据，以及各个任务使用的翻译表。

每当一个应用程序启动时，操作系统会为其分配一组翻译表条目，将该应用程序使用的代码和数据映射到物理内存中。如果应用程序需要映射代码或额外的数据空间（例如通过 `malloc()` 调用），内核可以随后修改这些表。当任务完成且应用程序不再运行时，内核可以移除所有相关的翻译表条目，并将空间重新分配给新的应用程序。通过这种方式，多个任务可以同时驻留在物理内存中。在任务切换时，内核会切换翻译表条目，切换到要运行的下一个线程。此外，处于休眠状态的任务完全受到正在运行任务的保护。MMU 可以防止正在运行的任务访问其他任务的代码或数据。

#### 地址空间 ID (ASID)

在介绍二级翻译表中的位时，我们提到一个名为 nG（非全局）的位。如果某个页面设置了 nG 位，则该页面与特定应用程序相关联。当 MMU 进行地址翻译时，它使用虚拟地址和 ASID 值。

ASID 是操作系统分配给每个任务的编号，范围为 0-255。当前任务的 ASID 值写入 ASID 寄存器中（通过 CP15 c13 访问）。当 TLB 更新且条目标记为非全局时，ASID 值将存储在 TLB 条目中，除了正常的翻译信息之外，后续的 TLB 查找只有在当前 ASID 与存储在条目中的 ASID 匹配时才会命中。因此，您可以为同一页面（标记为非全局）在 TLB 中有多个有效条目，但它们具有不同的 ASID 值。这显著减少了上下文切换的软件开销，因为它避免了清空片上 TLB 的需求。ASID 也是更大（32 位）进程 ID 寄存器的一部分，该寄存器可用于任务感知的调试。

##### 注意

上下文切换指的是调度器将执行从一个进程转移到另一个进程。这通常需要保存当前进程的状态，并恢复下一个等待运行的进程的状态。

图 9-11 说明了这一点。在这里，您有多个应用程序（A、B 和 C），它们都链接到从虚拟地址 0 开始运行。每个应用程序位于物理内存中的一个单独地址空间中。与每个应用程序关联的 ASID 值允许您在任何特定时间内在 TLB 中有多个条目，这些条目对虚拟地址 0 有效。

---

### 9.7.2 翻译表基地址寄存器 0 和 1

管理具有各自翻译表的多个应用程序时的一个潜在问题是，每个应用程序都可能有一个 L1 翻译表的副本。每个 L1 翻译表大小为 16KB。大多数情况下，这些表中的条目是相同的，因为通常只有一个内存区域是特定于任务的，而内核空间在每个表中保持不变。此外，如果需要修改全局翻译表条目，则必须在每个表中进行更改。

为帮助减少这些问题的影响，提供了第二个翻译表基地址寄存器。CP15 包含两个翻译表基地址寄存器：TTBR0 和 TTBR1。一个控制寄存器（TTB 控制寄存器）用于编程一个范围为 0 到 7 的值。这个值（记作 N）告诉 MMU 它必须检查虚拟地址的多少高位，以确定使用哪个 TTB 寄存器。

- 当 N 为 0（默认值）时，所有虚拟地址都使用 TTBR0 进行映射。
- 当 N 的值在 1 到 7 之间时，硬件会查看虚拟地址的最高位。如果 N 位的最高位全为 0，则使用 TTBR0；否则，使用 TTBR1。

例如，如果 N 设置为 7，则底部 32MB 的内存将使用 TTBR0，其余内存将使用 TTBR1。因此，TTBR0 指向的应用程序特定的翻译表只包含 32 个条目（128 字节）。全局映射位于 TTBR1 指向的表中，并且只需要维护一个表。

使用这些功能时，上下文切换通常要求操作系统更改 TTBR0 和 ASID 值，使用 CP15 指令。然而，由于这两个操作是非原子的，因此需要特别小心，以避免使用新寄存器值与旧寄存器值组合时出现推测性访问问题。使用这些功能的操作系统程序员应熟悉 ARM 架构参考手册中为此目的推荐的操作顺序。

---

### 9.7.3 快速上下文切换扩展 (FCSE)

快速上下文切换扩展 (FCSE) 在 ARMv4 架构中引入，但自 ARMv6 以来已弃用。它允许多个独立任务在虚拟内存空间的底部固定、重叠区域中运行，而不需要在上下文切换时清理缓存或 TLB。FCSE 通过修改虚拟地址，将进程 ID 值替换到虚拟地址的最高 7 位（但仅当该地址位于内存的底部 32MB 时）。一些 ARM 文档区分了修改虚拟地址 (MVA) 和虚拟地址 (VA)，这种区分仅当使用 FCSE 时才有意义。


