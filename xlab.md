### 4.17. 翻译（XLAT）表库

本文档描述了 Trusted Firmware-A (TF-A) 使用的翻译表库（第2版）的设计。该库提供了用于根据内存布局描述创建页表的API，还包括设置与内存管理单元（MMU）相关的系统寄存器，并执行所需的转换后备缓冲（TLB）维护操作。

更具体地说，该库旨在支持以下几种用例：

- 静态分配翻译表，并在运行时根据内存布局描述填充它们。内存布局通常由平台端口提供，作为内存区域列表；
- 支持生成与库代码执行所在的异常级别不同的翻译机制相关的翻译表；
- 支持在MMU开启的情况下，动态映射和取消映射区域。这可以用于临时映射一些内存区域，并在不再需要时取消映射；
- 支持非一致的虚拟到物理映射，以压缩虚拟地址空间；
- 支持在运行时更改内存区域的内存属性。

### 4.17.1 关于版本1、版本2和MPU库

本文档重点关注库的第2版，其源代码可在相应目录中找到。库的第1版也可以在目录中找到，但其灵活性较差，并且不支持动态映射。此外，本文还讨论了Arm的MPU配置库。MPU库目前仍处于实验阶段，意味着其API可能会发生变化。MPU库当前力求与 `xlat_tables_v2` 保持一致性并重用代码。未来版本可能会更专注于MPU特性（例如，去除所有虚拟地址相关内容）。虽然所有 `xlat_*` 库的潜在错误修复都会被应用，但未来的功能增强将主要集中在第2版上，可能不会回溯到第1版和MPU版本。因此，建议使用第2版，特别是对于新平台端口（除非平台使用MPU）。

然而，请注意，第2版和MPU版本仍在积极开发中，尚未被视为稳定版本。因此，可能会引入不兼容的变化。

从本文档的此处开始，除非另有说明，均默认指库的第2版。

### 4.17.2 设计概念与接口

本节介绍了翻译表库中使用的一些关键概念和数据结构。

#### 4.17.2.1 `mmap` 区域

`mmap_region` 是表示内存区域映射的抽象方式，是该库的关键接口之一。它由以下内容标识：

- 物理基地址；
- 虚拟基地址；
- 大小；
- 属性；
- 映射粒度（可选）。

请参阅 `xlat_tables_v2.h` 中的 `struct mmap_region` 类型定义。

用户通常会提供一个这样的 `mmap` 区域列表，交由库将其转换为一组翻译表。库可能会因此创建新翻译表、更新或拆分现有表。

区域属性指定了内存类型（例如设备内存或缓存的普通内存）以及内存访问权限（只读或读写，可执行或不可执行，安全或非安全等）。在 EL1&0 翻译机制下，属性还指定该区域是用户区域（EL0）还是特权区域（EL1）。请参阅 `xlat_tables_v2.h` 中的 `MT_xxx` 定义。注意，对于 EL1&0 翻译机制，`Execute Never` 属性同时适用于 EL1 和 EL0。

粒度控制映射区域时深入到的翻译表级别。例如，假设 MMU 被配置为使用 4KB 的粒度大小，库可以通过以下两种方式之一来映射 2MB 的内存区域：

- 使用单个二级翻译表项；
- 使用二级中间表项指向三级翻译表（该表包含 512 个条目，每个条目映射 4KB）。

第一种方案可能需要较少的翻译表，因此潜在地节省了内存。然而，如果该 2MB 区域的一部分稍后使用不同的内存属性重新映射，库可能需要拆分现有页表以细化映射。如果在此处使用了单个二级条目，则需要动态分配一个三级表，并修改二级表以指向该新的三级表。这会在运行时带来性能开销。

如果用户预先知道这种重新映射操作可能会发生，则可以从一开始就为该 2MB 区域强制使用 4KB 的映射粒度；之后动态重新映射某些 4KB 页将成为轻量级操作。

区域的粒度是一个可选字段；如果未指定，库将根据需要为该区域选择映射粒度（更多详细信息请参阅下文的“内存映射算法”部分）。

MPU 库也使用 `struct mmap_region` 来指定翻译，但 MPU 的翻译仅限于指定有效地址和访问权限。如果请求的虚拟地址和物理地址不匹配，系统将发生崩溃。由于是基于寄存器的设计以确保确定性的内存引用时间，MPU 硬件不涉及基于内存的翻译表。

当前，MPU 库仅限于在 EL2 处执行 MPU 翻译，其他 ELs 不涉及 MMU 翻译。然而，预计未来版本的库将克服这些限制。

#### 4.17.2.2 翻译上下文

该库可以创建或修改与库代码执行所在异常级别不同的翻译机制相关的翻译表。例如，EL3 软件（如 BL31）可以使用该库创建与 S-EL1&0 翻译机制相关的翻译表。

这种灵活性来源于翻译上下文的使用。翻译上下文是库用于跟踪给定翻译机制的翻译表状态的超集信息。

库内部分配了一个默认的翻译上下文，该上下文与当前异常级别的翻译机制相关。也可以显式分配和初始化额外的上下文，使用宏 `REGISTER_XLAT_CONTEXT()`。库提供了单独的 API 来操作默认的翻译上下文或其他上下文。

要注册一个翻译上下文，用户必须向库提供以下信息：

- 名称：生成的翻译上下文变量将以此名称命名，并附加 `_xlat_ctx` 后缀。例如，如果宏名称参数是 `foo`，则上下文变量名为 `foo_xlat_ctx`。
- 要映射的最大 `mmap` 区域数量：如果适用，应考虑静态和动态区域。
- 要分配的子翻译表数量：指定静态分配的翻译表数量，不包括初始查找级别的翻译表（该表始终被分配）。例如，如果初始查找级别是 1，则该参数指定为该上下文预先分配的二级和三级翻译表的数量。
- 虚拟地址空间的大小：使用此上下文映射的虚拟地址空间大小（以字节为单位）。这将间接决定初始查找级别翻译表中的条目数量：库将分配足够多的条目以映射整个虚拟地址空间。
- 物理地址空间的大小：使用此上下文映射的物理地址空间大小（以字节为单位）。

默认的翻译上下文是根据平台特定的定义信息进行初始化的：

- 名称：硬编码为 `tftf`，因此默认上下文变量名为 `tftf_xlat_ctx`；
- `mmap` 区域数量：`MAX_MMAP_REGIONS`；
- 子翻译表数量：`MAX_XLAT_TABLES`；
- 虚拟地址空间大小：`PLAT_VIRT_ADDR_SPACE_SIZE`；
- 物理地址空间大小：`PLAT_PHY_ADDR_SPACE_SIZE`。

请参阅移植指南获取有关这些宏的更多详细信息。

#### 4.17.2.3 静态和动态内存区域

该库可选地支持动态内存映射。此功能可以通过平台构建标志 `PLAT_XLAT_TABLES_DYNAMIC` 启用。

启用动态内存映射后，库将 `mmap` 区域分类为静态或动态区域。

- **静态区域**：在系统生命周期内固定不变。它们只能在早期添加，在翻译表创建和填充之前。之后无法移除。
- **动态区域**：可以随时添加或移除。

如果禁用了动态内存映射功能，则仅存在静态区域。

动态内存映射功能可用于映射和取消映射临时内存区域。这对于需要在固定时间段内访问某些内存的情况非常有用，之后这些内存可以被丢弃并回收。例如，仅在系统初始化时需要的启动时内存区域，或者用于在普通世界和可信世界之间临时共享内存缓冲区的区域。注意，调用方必须确保在添加或移除这些区域时，不能同时访问这些区域。

尽管此功能提供了一定程度的动态内存分配，但这并不允许动态分配任意数量的内存或在任意内存位置进行分配。用户仍需在编译时声明这些分配的限制；库将拒绝任何不符合预分配内存池的映射请求。

### 4.17.3 库的 API

该库公开的外部 API 都在头文件 `xlat_tables_v2.h` 中声明和记录。这个文件应该作为获取该库提供的不同 API 信息的参考点。本节仅提供一些额外的细节和说明。

虽然 `mmap_region` 结构体是公开可见的类型，但不建议手动填充这些结构体。相反，凡是 API 需要 `mmap_region_t` 类型的函数参数时，应该使用一系列辅助宏来构造它们。这是为了减少未来如果结构体类型发生变化时的兼容性风险。常用的构造宏有 `MAP_REGION*()` 系列。

`MAP_REGION()` 和 `MAP_REGION_FLAT()` 宏不允许指定映射粒度，因此库的实现可以自由选择粒度。然而，如果需要特定的粒度，可以使用 `MAP_REGION2()` 宏。强烈建议仅使用 `MAP_REGION_FLAT()` 来为 MPU 库定义区域。

正如本文档前面所述，当禁用动态映射功能时，概念上只存在静态区域。因此，为了保持与库的第一版的向后兼容，映射静态区域的 API 函数名中不包含“静态”一词（例如 `mmap_add_region()`），而映射动态区域的 API 则包含了“动态”一词（例如 `mmap_add_dynamic_region()`）。

尽管静态和动态区域的定义与 MMU 的状态无关，但两者之间仍有一定的关联。静态区域只能在调用 `init_xlat_tables()` 之前添加，且必须在 MMU 关闭时调用。因此，一旦启用了 MMU，就不能再添加静态区域。而动态区域可以在 MMU 开启或关闭时添加。实际上，常见的调用流程如下所示：

1. **初始状态下 MMU 是关闭的**。
2. 添加一些静态区域，再添加一些动态区域。
3. 基于 `mmap` 区域列表初始化翻译表（使用 `init_xlat_tables*()` 系列的 API）。
4. **此时不再能添加静态区域**，但仍然可以添加或移除动态区域。
5. 启用 MMU。
6. **动态区域仍可以继续添加或移除**。

由于静态区域在启动时早期添加，且完全由平台初始化代码控制，因此 `mmap_add*()` 系列 API 不太可能失败。它们不会返回任何错误代码。

尽管如此，这些 API 会在更新翻译上下文结构之前检查是否可以成功添加区域。如果库检测到内存不足以满足请求，或者新区域与另一个区域无效重叠，或者遇到任何其他意外错误，库会在 UART 上打印错误消息。此外，当断言启用（通常在调试版本中）时，会触发断言。否则，函数调用会立即返回，而不会添加违规的内存区域。

### 4.17.4 库的限制

- **动态区域不允许彼此重叠**。
- **静态区域允许重叠**，只要其中一个区域完全包含在另一个区域之内。这种行为是为了与库的第一版的先前行为保持向后兼容。
### 4.17.5 实现细节

#### 4.17.5.1 代码结构

该库分为四个模块：

- **核心模块**  
  提供库的主要功能，例如翻译表上下文的初始化和内存区域的映射/取消映射。该模块提供了类似 `mmap_add_region_ctx` 的函数，允许调用者指定受影响的翻译表上下文。

  请参阅 `xlat_tables_core.c`。

- **活动上下文模块**  
  实例化当前 BL 镜像使用的上下文，并提供帮助程序来操作它，将其与代码的其余部分抽象开来。该模块提供了类似 `mmap_add_region` 的函数，直接影响使用它们的 BL 镜像。

  请参阅 `xlat_tables_context.c`。

- **实用模块**  
  提供额外的功能，如当前翻译表状态的调试打印，内存属性查询的帮助程序，以及修改内存属性的函数。

  请参阅 `xlat_tables_utils.c`。

- **架构模块**  
  提供与当前执行状态（AArch32/AArch64）相关的函数，例如用于 TLB 失效、设置 MMU 或计算物理地址空间大小的函数。这些函数不需要翻译上下文即可工作。

  请参阅 `aarch32/xlat_tables_arch.c` 和 `aarch64/xlat_tables_arch.c`。

#### 4.17.5.2 从 `mmap` 区域到翻译表

一个翻译上下文包含一个 `mmap_region_t` 列表，该列表保存了当前映射的所有区域的信息。每当请求映射（或取消映射）一个内存区域时，它将被添加到（或从）该列表中删除。

`mmap` 区域列表是表示内存布局的一种概念方式。某个时刻，库必须将这些信息转换为实际的翻译表，以便在 MMU 中编程。

在调用 API 之前，库仅对 `mmap` 区域列表操作。此时通过任何 API 添加静态或动态区域都不会影响翻译表，它们只会被注册到内部的 `mmap` 区域列表中。只有当用户调用 `init_xlat_tables()` 时，翻译表才会根据迄今注册的 `mmap` 区域列表填充到内存中。这是一种优化，允许一次性创建初始的翻译表，而不是在每次 MMU 关闭时编辑它们。

一旦调用了 `init_xlat_tables()`，之后只能添加动态区域。对翻译表（以及 `mmap` 区域列表）的更改将立即生效。

#### 4.17.5.3 内存映射算法

映射函数作为递归算法实现。不过，该算法受限于翻译表的深度级别（Armv8-A 架构最多允许 4 级查找）。

默认情况下，算法会尝试最小化为满足用户请求而创建的翻译表数量。它倾向于使用尽可能大的块来映射区域，只有在绝对必要的情况下才会创建子表。这是为了减少固件的内存占用。

最常见的需要子表的原因是某些特定映射需要更细的粒度。未对齐的区域也需要比用户预期更细的粒度，使用的内存可能比预期多得多。原因是所有翻译级别都必须遵循与该级别块大小相同的粒度。例如，对于 4 KiB 页大小，二级块条目最多只能翻译到 2 MiB 的粒度。如果物理地址未对齐到 2 MiB，则需要额外的三级表。

请注意，并非每个翻译级别都允许使用任何类型的描述符。根据页大小，翻译的第 0 和第 1 级可能只允许表描述符。如果块条目能够描述翻译，但该级别不允许块描述符，则必须使用表描述符，并且需要下一级的额外表。

**对齐示例**

`mmap` 区域按一定顺序排序，以简化映射它们的代码。尽管这种排序仅对重叠的静态区域严格要求，但也必须对动态区域应用此排序，以始终保持所有区域的一致顺序。每次映射新区域时，都会检查翻译表中的现有条目以确保一致性。有关排序算法的更多详细信息，请参阅核心模块源码中的注释。

此映射算法不适用于 MPU 库，因为 MPU 硬件直接通过“基址”和“限制地址”（底部和顶部）来映射区域。

#### 4.17.5.4 TLB 维护操作

库会在需要时执行 TLB 维护操作。例如，当用户请求移除动态区域时，库会使与该区域相关的所有 TLB 条目失效，以确保这些更改对后续的执行可见，包括使用更改后的翻译表条目的推测性执行。

一个反例是翻译表的初始化。在这种情况下，不需要显式的 TLB 维护操作。Armv8-A 架构保证所有 TLB 在复位时被禁用，其内容在重置时对地址转换没有影响。因此，TLB 的失效操作会延迟到 `enable_mmu*()` 系列函数调用之前执行，即在 MMU 启用之前。

关于启用和禁用内存管理，为了避免混淆，MPU 库中启用或禁用 MPU 的调用名称中使用 `mpu`，而不是 `mmu`。例如，`enable_mmu_el2()` 被改为 `enable_mpu_el2()`。

添加动态区域时也不需要 TLB 失效操作。动态区域不允许与现有内存区域重叠。因此，如果动态映射请求被认为是合理的，它自动涉及在此翻译机制中未映射的内存，并且库会将其相应的翻译表条目初始化为无效描述符。由于架构上不允许 TLB 持有任何无效的翻译表条目，这意味着该映射无法被缓存到 TLB 中。

#### 注释

1. 当 `mmap` 区域不强制其映射粒度时，算法才会按默认方式执行。
2. 参见 Armv8-A 架构 C.a 修订版的 D4.9 节，译后缓冲器（TLB）行为在复位时的子节。
3. 参见 Armv8-A 架构 C.a 修订版的 D4.10.1 节，TLB 维护的一般要求。