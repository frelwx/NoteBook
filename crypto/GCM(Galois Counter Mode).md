
在密码学中，伽罗瓦/计数器模式（GCM）[1]是一种对称分组加密算法的工作模式，因其良好的性能而被广泛采用。最快速的GCM通信信道可以用便宜的硬件来实现[2]。

GCM算法提供数据真实性（与完整性）和机密性的验证，基于关联数据认证加密（AEAD）方法。这表示它需要密钥K、明文P和一些附加数据（associated data，以下简称AD）作为输入；然后使用密钥对明文 P 加密得到密文 C，并根据密文和AD（未加密）的计算来得到认证标签 T。知道K（密钥）的接收者在收到AD、C（密文）和T（认证标签）后可以解密密文以得到P（明文），并且可以检查T（认证标签）以确保密文和AD都没有被篡改。

GCM使用块大小为128位的块密码（通常为AES-128）的计数器模式进行加密，并使用伽罗瓦域GF中的算术来计算认证标签；因此得名。

伽罗瓦消息认证码（GMAC）是GCM的一种仅用于认证的变体，可以形成增量消息认证码。GCM和GMAC都可以接受任意长度的初始化向量。
![[Pasted image 20241202222039.png]]
首先用CTR加密，然后对密文使用类似CBC的方式进行加密（实际上是GHASH）。GHASH的效率比CBC更高

![[Pasted image 20241202223636.png]]
### 1 引言

Galois/Counter Mode（GCM）是一种分组密码操作模式，它通过使用二元Galois域上的通用哈希来提供认证加密。GCM可以通过硬件实现来达到高速度，同时具备低成本和低延迟的优势。而在软件中，通过基于表驱动的域操作也可以获得优秀的性能。该模式采用了具有良好理论基础的机制，其安全性基于对分组密码安全性单一且合理的假设。

目前迫切需要一种操作模式，能够在硬件中以每秒10Gbps及以上的速度高效地实现认证加密，同时在软件中表现良好，并且不受知识产权限制的约束。该模式必须支持流水线和并行化实现，并具有最小的计算延迟，以便在高数据速率场景下使用。计数器模式（Counter Mode）因满足这些需求而被认定为实现高速加密的最佳方法。然而，目前并没有一个合适的标准化消息认证算法。这导致我们虽然能够以高速加密数据，却无法提供与加密速度匹配的消息认证功能。特别是，计数器模式本身无法防止比特翻转攻击，这一缺陷尤为明显。

GCM模式填补了这一空白，而其他提议的模式并未同时满足这些标准。CBC-MAC [1, 附录F] 及使用其提供认证的模式（如CCM [2]、EAX [3] 和OMAC [4]）无法实现流水线或并行化，因此不适合高数据速率场景。OCB [5] 则涉及多个知识产权的主张。CWC [6] 虽不具备上述问题，但对于高速实现而言仍不够理想。具体来说，CWC的消息认证组件使用了127位整数乘法操作，其实现成本甚至超过了AES计数器模式的高速实现，并且其电路深度是GCM的两倍。相比之下，GCM用于认证的二进制域乘法在高速实现中的成本仅为计数器模式的一小部分。

此外，GCM还具备一些其他有用的特性。它能够作为一个独立的MAC（消息认证码）工作，即使在没有数据加密的情况下也可以对消息进行认证，且不需要任何修改。更重要的是，GCM可以用作增量式MAC [7]：如果已经计算出某条消息的认证标签，当消息的部分内容发生变化时，只需针对变更的位数重新计算认证标签，其计算成本与变更的位数成正比。这一特性在所有提出的模式中是独一无二的。

另一个实用的特性是，GCM接受任意长度的初始化向量（IV）。这使得应用程序更容易满足“所有IV必须唯一”的要求。在许多需要认证加密的场景中，存在可以用作随机数（nonce）或其一部分的数据元素，但这些元素的长度可能超过密码的分组长度。而GCM允许使用任意大小的随机数作为IV。这一特性在EAX模式中也存在，但在其他模式中则不具备。

### 建议模式

本文档的组织结构如下：第2节包含GCM的完整规范，这是本文档的唯一规范性部分。第3节提供有限域的概述，并详细描述了GCM中使用的字段表示方式。第4节描述了实现策略，并讨论了这些策略的性能。第6节总结了该模式的特性，并阐述了其设计的理论依据，同时提供与其他模式的详细性能比较。第7节总结了安全性分析。附录A描述了GCM在64位分组密码中的使用。附录B包含了可用于验证AES GCM实现的测试数据。

---

### 2 定义

本节包含GCM针对128位分组密码的完整定义。当应用于64位分组密码时，模式会略有不同，这些差异在附录A中进行了概述。

#### 2.1 输入和输出

GCM具有两种操作：**认证加密**和**认证解密**。认证加密操作有四个输入，每个输入都是一个比特串：

- **密钥 K**：这是一个秘密密钥，其长度应适配于底层分组密码的要求。
- **初始化向量 IV**：可以是1到2<sup>64</sup>位之间的任意长度比特串。对于固定密钥，每个IV值必须唯一，但长度可以不相等。96位的IV值可以更高效地处理，因此在对效率要求较高的场景中推荐使用该长度。
- **明文 P**：可以是0到2<sup>39</sup> − 256位之间的任意长度比特串。
- **附加认证数据（AAD） A**：该数据仅用于认证而不进行加密，其长度可以是0到2<sup>64</sup>位之间的任意比特串。

有两个输出：

- **密文 C**：其长度与明文 P 的长度完全一致。
- **认证标签 T**：用于验证数据完整性和认证。
- **认证标签 T**：其长度可以在0到128位之间的任意值，记作 \(t\)。

**认证解密操作**有五个输入：\(K\)、\(IV\)、\(C\)、\(A\) 和 \(T\)。其输出只有一个，要么是明文值 \(P\)，要么是一个特殊符号 **FAIL**（表示输入数据不具有真实性）。当密文 \(C\)、初始化向量 \(IV\)、附加认证数据 \(A\) 和标签 \(T\) 是由加密操作通过输入 \(K\)、\(IV\)、\(A\) 和某个明文 \(P\) 生成时，它们对于密钥 \(K\) 是认证的。如果认证解密操作的输入未使用相同密钥通过加密操作生成，则该操作将以很高的概率返回 **FAIL**。

**附加认证数据（AAD）** \(A\) 用于保护需要认证但必须保持未加密的信息。在使用GCM保护网络协议时，此输入可以包括地址、端口、序列号、协议版本号以及其他指示如何处理、转发或处理明文的字段。在许多情况下，尽管这些字段必须保持明文以确保网络或系统正常运行，但对它们进行认证是非常重要的。当这些数据包含在AAD中时，可以在无需将数据复制到密文中的情况下提供认证。

**初始化向量（IV）** 的主要用途是作为一个 **nonce**（随机数），即对于固定密钥的每次加密操作，IV必须是唯一的。只要IV值的唯一性高度可能（例如通过随机生成），就可以接受。IV本身是经过认证的，因此无需将其包含在AAD字段中。

GCM对明文同时提供了机密性和消息认证功能。对于 \(P\)、\(IV\) 和 \(A\) 的认证强度取决于认证标签的长度 \(t\)。当明文 \(P\) 的长度为零时，GCM相当于对输入 \(A\) 执行MAC（消息认证码）操作。将GCM独立用作消息认证码的模式称为 **GMAC**。

在第5节中提供了一个GCM在网络安全中的示例，展示了如何在典型的加密应用中使用其输入和输出。

---

### 2.2 符号表示法

本部分采用了《分组密码操作模式推荐规范》[8]中的符号表示法。GCM中使用的两个主要函数是：

- **分组加密** 和  
- **有限域 \(GF(2^{128})\) 上的乘法**。

**分组加密**操作表示为 \(E(K, X)\)，其中 \(X\) 是加密值，\(K\) 是密钥。  
**有限域乘法**表示为 \(X \cdot Y\)，其中 \(X, Y \in GF(2^{128})\)。  
**加法**表示为 \(X \oplus Y\)，它是逐位的异或操作。

在有限域中，加法等同于逐位异或操作，乘法的定义在第2.5节中给出。

以下是符号和函数的定义：

1. **len()**：返回一个64位字符串，表示其参数的比特长度（非负整数），最低有效位（LSB）在右侧。
2. **\(0^l\)**：表示一个由 \(l\) 个零组成的比特串。
3. **\(A || B\)**：表示两个比特串 \(A\) 和 \(B\) 的连接。
4. **MSB\(_t(S)\)**：返回比特串 \(S\) 的前 \(t\) 位（最左侧的高位）。
5. **\(\{\}\)**：表示长度为零的空比特串。

这些符号将在后续描述GCM的操作逻辑和计算过程中被频繁使用。


### 2.3 加密

设 \(n\) 和 \(u\) 为唯一的一对正整数，使得明文的总比特数等于 \((n − 1)128 + u\)，其中 \(1 ≤ u ≤ 128\)。明文由 \(n\) 个比特串组成，其中最后一个比特串的长度为 \(u\)，其余比特串的长度为 128 位。这些比特串依次表示为 \(P_1, P_2, ..., P_{n−1}, P^∗\)，这些比特串被称为数据块（data blocks），尽管最后一个比特串 \(P^∗\) 可能不是完整的块。同样，密文表示为 \(C_1, C_2, ..., C_{n−1}, C^*\)，其中最后一个块 \(C^*\) 的比特长度为 \(u\)。

额外的认证数据（Authenticated Data）表示为 \(A_1, A_2, ..., A_{m−1}, A^∗\)，其中最后一个比特串 \(A^∗\) 可能是长度为 \(v\) 的部分块。设 \(m\) 和 \(v\) 为唯一的一对正整数，使得 \(A\) 的总比特数等于 \((m − 1)128 + v\)，且 \(1 ≤ v ≤ 128\)。

认证加密操作通过以下公式定义：

- \( H = E(K, 0^{128}) \)
- 如果 \( len(IV) = 96 \):  
  \( Y_0 = IV || 0^{31} || 1 \)  
  否则:  
  \( Y_0 = GHASH(H, \{\}, IV) \)
- \( Y_i = incr(Y_{i−1}) \), \(i = 1, ..., n\)
- \( C_i = P_i \oplus E(K, Y_i) \), \(i = 1, ..., n−1\)
- \( C^* = P^* \oplus MSB_u(E(K, Y_n)) \)
- \( T = MSB_t(GHASH(H, A, C) \oplus E(K, Y_0)) \)

**说明：**

- 连续的计数器值（Counter Values）由函数 \(incr()\) 生成。该函数将输入参数的最右 32 位视为非负整数（最低有效位在最右侧），并对其值进行模 \(2^{32}\) 的递增操作。更正式地，函数 \(incr(F_i)\) 的值为 \(F_i((I + 1) \mod 2^{32})\)。
  
- 加密过程如图 1 所示。

函数 **GHASH** 的定义为：  
\( GHASH(H, A, C) = X_{m+n+1} \)，其中输入 \(A\) 和 \(C\) 是...  

（剩余部分未提供，但这里是对加密逻辑和相关操作的描述。）

---

### 译注：
1. **符号解释：**
   - \(E(K, X)\): 表示使用密钥 \(K\) 对数据 \(X\) 进行加密。
   - \(MSB_u(X)\): 表示取 \(X\) 的最高 \(u\) 位。
   - \(GHASH(H, A, C)\): 是一个基于伽罗瓦域的哈希函数。
   - \(⊕\): 表示按位异或操作。

2. **逻辑优化：**
   翻译过程中已在语句间加入适当的换行和分段，使公式和文本逻辑更加清晰，便于理解。

如果需要图解或后续部分的补充，请继续提供内容！