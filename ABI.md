# 第十五章 应用程序二进制接口

C 语言编译器能够从多个独立编译的模块生成代码。为了使程序能够成功执行，这些模块必须能够与操作系统代码以及任何用汇编语言或其他编译语言编写的代码进行互操作。因此，我们必须定义一套规范来管理不同代码片段之间的互操作性。

ARM 架构规范的应用程序二进制接口（ABI）描述了一组规则，ARM 可执行文件必须遵守这些规则才能在特定环境中运行。它规定了可执行文件的约定（包括文件格式），并确保来自不同编译器或汇编器的对象文件能够成功链接在一起。ABI 还针对特定用途有不同的变体，例如 ARM 架构的 Linux ABI 或嵌入式应用程序二进制接口（EABI）。

ARM 架构过程调用标准（AAPCS）是 ABI 的一部分（尽管 ABI 实际上称之为 ARM 架构的过程调用标准）。它规定了编译器和子程序调用期间寄存器和堆栈的使用规范。了解这些规则对于 C 语言和汇编代码的互操作至关重要，也有助于编写优化的代码。AAPCS 取代了之前的 ARM-Thumb 过程调用标准（ATPCS）。

AAPCS 规定了调用方必须遵守的规则，以便被调用的函数能够运行；同时也规定了被调用的例程必须做什么，以确保调用方在被调用函数返回后能够继续正常运行。它描述了数据在内存中的布局方式以及堆栈的布局方式，还涵盖了处理器扩展的允许变体。它定义了如何使独立编译或汇编的代码协同工作。
### 15.1 过程调用标准

如前所述，核心中有 16 个 32 位整数寄存器可用，这些寄存器编号为 R0 至 R15。表 15-1 显示了在过程调用标准中为各寄存器分配的角色。
![[Pasted image 20241113223832.png]]
为了便于函数调用，寄存器被划分为以下三组：

- **参数寄存器 R0-R3 (a1-a4)**：这些寄存器可以用作临时寄存器，或者作为调用者保存的寄存器变量，可以在例程中保存中间值，并在调用其他函数之间使用。
  
- **被调用者保存的寄存器**：通常用于寄存器变量。通常，R4-R8、R10 和 R11（v1-v5、v7 和 v8）寄存器用于此目的。

- **具有专用功能的寄存器**：程序计数器（PC）、链接寄存器（LR）和堆栈指针（SP）的功能应该很明确。如果不清楚，请参阅第 3-6 页中的“寄存器”部分。

IP 寄存器（R12）可以被链接器用作临时寄存器，适用于例程和它调用的任何子例程之间，或者作为函数中的额外本地变量。由于 `BL` 指令不能访问完整的 32 位地址空间，链接器可能需要插入过渡代码（veneer）来连接调用者和被调用者。过渡代码也可用于 ARM-Thumb 互操作或动态链接，并且允许修改 IP（R12）的内容。

### 表 15-1 APCS 寄存器

| 寄存器  | PCS 名称 | PCS 角色                      |
| ------- | -------- | ----------------------------- |
| R0      | a1       | 参数 1/临时寄存器/结果         |
| R1      | a2       | 参数 2/临时寄存器/结果         |
| R2      | a3       | 参数 3/临时寄存器/结果         |
| R3      | a4       | 参数 4/临时寄存器/结果         |
| R4      | v1       | 寄存器变量                    |
| R5      | v2       | 寄存器变量                    |
| R6      | v3       | 寄存器变量                    |
| R7      | v4       | 寄存器变量                    |
| R8      | v5       | 寄存器变量                    |
| R9      | tr/sb/v6 | 静态基址/寄存器变量           |
| R10     | v7       | 寄存器变量                    |
| R11     | v8       | 寄存器变量                    |
| R12     | IP       | 临时寄存器/跨链接单元调用时的新 -sb |
| R13     | SP       | 堆栈指针，总是指向堆栈顶部      |
| R14     | LR       | 链接寄存器/临时寄存器           |
| R15     | PC       | 程序计数器                    |

> **注释**：ARM 指令集提供了支持不同类型堆栈实现的指令，但 ABI 仅使用全降序堆栈。

R9 寄存器的角色在特定环境中有所不同。它可以用作静态基址寄存器（SB），指向位置无关的数据，或者在使用线程局部存储时作为线程寄存器（TR）。如果代码不需要这样的特殊寄存器，它可以用作额外的被调用者保存的变量寄存器，即 v6。

传递给函数的前四个字大小的参数会通过 R0-R3 寄存器传递。对于小于字大小的参数（例如 `char`），仍然会占用一个完整的寄存器。大于一个字的参数将通过多个寄存器传递。如果有超过四个参数，超过的参数将通过堆栈传递。通过堆栈传递参数需要额外的指令和内存访问，因此会降低性能。为了优化代码，应该尽量将参数数量限制为四个字或更少。如果无法做到这一点，最常用的参数应放在函数定义的前四个位置。如果参数属于一个结构体，则传递该结构体的指针可能会更高效。

在 C++ 中，第一个参数用于传递 `this` 指针给成员函数，因此只有三个参数可以通过寄存器传递。

### 64 位类型的额外规则

64 位类型必须在内存中保持 8 字节对齐。请回顾第 14-5 页中关于对齐的描述，那里提到 `LDRD` 和 `STRD` 双字指令不能用于未对齐的地址。此外，传递给函数的 64 位参数必须使用相邻的偶数和奇数寄存器对（例如 R0 + R1 或 R2 + R3）。

如果 64 位参数通过堆栈传递，它们必须位于 8 字节对齐的位置。这是因为 `LDRD` 和 `STRD` 指令的限制。如果 64 位参数排列不佳，可能会导致寄存器或堆栈中的空间浪费。在考虑这些问题时，必须记住在所有非静态 C++ 成员函数中，R0 中的 `this` 指针的存在。

### 64 位类型的规则

64 位类型必须在内存中按 8 字节对齐。回忆一下，在第 14-5 页的“对齐”部分，我们描述了 LDRD 和 STRD 双字指令在未对齐地址上的使用限制。此外，传递给函数的 64 位参数必须通过偶数寄存器和相邻的奇数寄存器对（例如，R0+R1 或 R2+R3）传递。

如果 64 位参数通过堆栈传递，它们必须位于 8 字节对齐的位置。同样，这是由于 LDRD 和 STRD 指令的限制。如果这些 64 位参数的顺序不佳，可能会导致寄存器或堆栈中的空间浪费。在考虑这些问题时，必须考虑到在所有非静态 C++ 成员函数中 R0 中传递的 `this` 指针。

### 参数传递示例

图 15-1 展示了一些参数顺序不佳的示例，这些示例会导致不必要的变量溢出到堆栈中。图中展示了两个不同的函数调用，它们传递相同的参数，并展示了寄存器和堆栈的使用情况。

第一个函数传递了一个 `int`、一个 `double` 以及一个额外的 `int`。第一个参数通过 R0 传递。第二个参数是 64 位的，必须通过偶数和相邻奇数寄存器（或堆栈中的 8 字节对齐位置）传递，因此它通过 R2 和 R3 传递。这意味着最后一个参数需要通过堆栈传递。

```
堆栈
R0
R1 R2 R3
Foo1 (int i0, double d, int i1)
i0
未使用
d
d
```

```
堆栈
R0
R1 R2 R3
Foo2 (int i0, int i1, double d)
i0
堆栈
i1
未使用
堆栈
i1
d
d
```

如上例所示，参数顺序的优化可以减少不必要的堆栈使用，从而提高代码的效率。

由于栈指针必须保持8字节对齐（这是ABI强加的约束，旨在简化函数边界的接口），因此在某些情况下会有额外的未使用字被压入和弹出栈。对于第二次函数调用，你可以通过寄存器 R0 和 R1 传递两个 `int` 值，通过 R2 和 R3 传递一个 `double` 值。这意味着没有任何值会被溢出到栈上，从而提高了代码效率，减少了指令数和内存访问。

寄存器 R4-R11（v1-v8）用于保存子程序的局部变量。如果子程序使用了 R4-R8、R10、R11 和 SP（以及在某些PCS变体中，R9 被指定为 v6），则子程序必须在栈上保存这些寄存器的内容。调用函数的代码如下所示：

```assembly
@ 可能需要保护 r0-r3
@ 不需要保护 r4-r11
BL Func
```

被调用函数的代码如下所示：

```assembly
Func:
@ 必须保护 r4-r11 和 lr（如果使用）
@ 可能会损坏 r0-r3、r12
PUSH {r4-r11, lr}
...
...
...
POP {r4-r11, pc}
@ 返回值在 r0 中 - char、short 或 int
@ 返回值在 r0 和 r1 中 - double
```

`PUSH/POP` 指令必须保持8字节栈对齐，因此使用偶数个寄存器。叶子函数（leaf function）不需要这样做。上面展示的被调用函数示例压入或弹出 R4-R11、LR 和 PC，但没有保持栈的8字节对齐。它被展示成这样是为了表明哪些寄存器必须保存。实际上，编译器通常会根据函数是否为叶子函数以及修改了哪些寄存器来决定是否压入额外的寄存器。实际的指令通常是以下形式之一：`PUSH/POP {r4, lr/pc}`，`PUSH/POP {r4-r8, lr/pc}`，`PUSH/POP {r4-r10, lr/pc}` 或 `PUSH/POP {r4-r12, lr/pc}`。在每种情况下，你都会压入 `lr` 并弹出 `pc`。

### 15.1.1 VFP 和 NEON 寄存器的使用

对ARM浮点运算不熟悉的读者可以在阅读本节之前参阅第6章“浮点运算”。

VFPv3 有32个单精度寄存器 `s0-s31`，它们也可以成对访问作为双精度寄存器 `d0-d15`。此外还有16个双精度寄存器 `d16-d31`。NEON 还可以将这些寄存器查看为四字寄存器 `q0-q15`。寄存器 `s16-s31`（`d8-d15`，`q4-q7`）必须在子程序调用之间保持不变；`s0-s15`（`d0-d7`，`q0-q3`）则不需要保持不变（并且可以用于在标准过程调用变体中传递参数或返回结果）。寄存器 `d16-d31`（`q8-q15`）不需要保持不变。

过程调用标准指定了两种传递浮点参数的方法。对于软件浮点运算，参数将通过 ARM 寄存器 R0-R3 传递，如果需要，则通过栈传递。另一种方式是在核心中有浮点硬件的情况下，参数可以通过 VFP 或 NEON 寄存器传递。

### 15.2 C 与汇编代码混合使用

了解 AAPCS（ARM 应用程序二进制接口标准）的一个实用之处在于，可以编写与 C 代码兼容的汇编代码。实现这一点的一种方法是编写独立的模块，并使用 GNU 汇编器 (GNU Assembler) 进行汇编。它们可以在 C 代码中定义为 `extern` 函数并调用。只要遵循 AAPCS 规则，应该不会有任何问题。

我们还可以通过 GCC 的 `asm` 语句将汇编代码插入到 C 代码中。这种方法非常简单。例如，我们可以通过 `NOP` 指令实现一个空操作，如 **示例 15-1** 所示。

#### 示例 15-1 NOP

```c
asm("nop");
```

执行 `NOP` 操作所需的时间是不确定的。

实际上，这个 `NOP` 很可能没有任何效果，因为 C 编译器可能会优化掉它，或者处理器内核可能会丢弃该指令。将汇编代码与内联汇编一起使用时，生成的代码仍然会受到 C 编译器的优化。这是一个非常重要的注意点，每当使用内联汇编时都必须考虑它。即使编译器没有优化掉 `NOP` 指令，处理器内核本身也可能过滤掉指令流中的 `NOP`，以至于它永远不会到达执行阶段。

内联汇编代码的语法与常规汇编代码不同。如果寄存器和常量引用了 C 表达式，则需要以不同的方式指定它们。

一个稍微复杂一些的例子是，获取一个 `int` 值并使用 `USAD8` 汇编指令计算字节差值的和，然后将结果存储在另一个 `int` 中。**示例 15-2** 展示了相关代码。

#### 示例 15-2 使用 USAD8 指令

```c
asm volatile ("usad8 %0, %1, %2" : "=r" (result) : "r"(value1), "r"(value2));
```

这种内联汇编代码的一般格式是：

```c
asm volatile (汇编指令 : 输出操作数 (可选) : 输入操作数 (可选) : 被破坏的寄存器 (可选));
```

冒号将语句分成不同的部分。第一部分 `"usad8 %0, %1, %2"` 是实际的汇编指令。第二部分是一个（可选的）输出值列表。如果需要多个输出，用逗号分隔各个条目。然后，你可以选择为该序列提供一个输入值列表，格式与输出部分相同。如果你没有为汇编序列指定输出操作数，C 编译器优化器很可能会认为它没有实际作用并将其优化掉！避免这种情况的方法是使用 `volatile` 属性，告诉 GCC 不要优化该序列。

在实际的汇编语言语句中，操作数通过百分号后跟方括号中的符号名来引用。符号名引用输入或输出操作数列表中具有相同名称的项。这个符号名与 C 代码中的任何其他符号完全不同（尽管显然使用在代码中有意义的符号会更清晰）。另外，也可以省略符号名，直接使用百分号后跟一个数字来指定操作数的位置（即 `%0`、`%1` ... `%9`），如示例所示。

### `asm` 语句中的可选部分：Clobber 列表

`asm` 语句有一个可选的第四部分，称为 **clobber 列表**。通过它，你可以向编译器指定汇编代码会修改哪些内容。可以指定寄存器（例如 R0）、条件码标志（cc）或内存。

这使得编译器在执行指令前先保存受影响的值，并在执行后重新加载这些值。

当我们谈到输入和输出操作数列表时，提到的约束条件是与汇编指令对操作数类型的具体要求相关的。传递参数给内联汇编指令时，编译器必须知道这些参数是如何表示的。例如，**约束符号** `"r"` 指定使用 ARM 状态下的寄存器 R0-R15，而 `"m"` 指定一个内存地址，`"w"` 则指定一个单精度浮点寄存器。这些约束符可以在前面加上 `=` 以表示**只写的输出操作数**，加上 `+` 表示**读/写的输出操作数**（即既是指令的输入又是输出）。`"&"` 修饰符则指示编译器不要为输出值选择任何同时用于输入操作数的寄存器。

### 强制使用特定寄存器

你可以通过类似 **示例 15-3** 中的代码，强制内联汇编使用特定的寄存器来保存局部变量。

#### 示例 15-3 内联汇编中的局部变量使用

```c
void func (void) {
    register unsigned int regzero asm("r0");
    ...
    asm volatile("rev r0, r0");
}
```

这种用法可能会干扰编译器优化，并且不能保证寄存器不会被重用，例如在局部变量不再被引用时。硬编码寄存器的使用总是不好的实践，几乎总是更好地使用局部变量代替。

### 更复杂的内联汇编示例

**示例 15-4** 提供了一个更长的内联汇编示例，取自 Linux 内核。它展示了如何使用一系列内联汇编指令。代码操作 CPSR 寄存器以改变模式，这是 C 代码无法实现的。

#### 示例 15-4 内联汇编

```c
void __naked get_fiq_regs(struct pt_regs *regs)
{
    register unsigned long tmp;
    asm volatile (
        "mov ip, sp\n"               /* 保存当前栈指针 */
        "stmfd sp!, {fp, ip, lr, pc}\n" /* 将帧指针、IP、LR、PC 压栈 */
        "sub fp, ip, #4\n"           /* 调整帧指针 */
        "mrs %0, cpsr\n"             /* 将当前 CPSR 寄存器值保存到 tmp */
        "msr cpsr_c, %2\n"           /* 切换到 FIQ 模式 */
        "mov r0, r0\n"               /* 空操作，确保指令顺序 */
        "stmia %1, {r8 - r14}\n"     /* 将 r8 到 r14 的寄存器内容保存到 regs 结构体 */
        "msr cpsr_c, %0\n"           /* 恢复原 CPSR 值，切换回 SVC 模式 */
        "mov r0, r0\n"               /* 空操作，确保指令顺序 */
        "ldmfd sp, {fp, sp, pc}"     /* 从栈中恢复帧指针、栈指针和程序计数器 */
        : "=&r" (tmp)                /* 输出操作数：保存 CPSR 的临时变量 */
        : "r" (&regs->ARM_r8),       /* 输入操作数：regs 的 ARM_r8 字段地址 */
          "I" (PSR_I_BIT | PSR_F_BIT | FIQ_MODE) /* 输入操作数：FIQ 模式的位掩码 */
    );
}
```

### 解释

1. 汇编代码使用 `asm volatile` 声明，防止编译器优化掉这段代码。
2. `mov ip, sp` 将栈指针复制到 IP 寄存器。
3. `stmfd sp!, {fp, ip, lr, pc}` 将帧指针、IP、链接寄存器（LR）和程序计数器（PC）压栈，保存现场。
4. `sub fp, ip, #4` 调整帧指针。
5. `mrs %0, cpsr` 将 CPSR 状态寄存器的值存储到临时变量 `tmp` 中。
6. `msr cpsr_c, %2` 切换到 FIQ 模式，`%2` 是输入操作数中的 `FIQ_MODE`。
7. `stmia %1, {r8 - r14}` 将 r8 到 r14 的寄存器内容存储到 `regs` 结构体中。
8. `msr cpsr_c, %0` 恢复之前保存的 CPSR 寄存器值，返回到 SVC 模式。
9. 最后，将栈中的帧指针和程序计数器恢复，返回调用者。

### Clobber 列表的使用

在这个例子中，clobber 列表部分通过 `=&r` 约束符确保 `tmp` 使用一个独立的寄存器，不与输入操作数冲突。

### ARM 编译器工具的类似概念

ARM 编译器工具也有类似的概念，尽管语法不同。除了内联汇编，它们还支持嵌入式汇编，嵌入式汇编是与 C 代码分开汇编的，并生成一个编译后的目标文件，最终与 C 编译的目标文件结合。

这种方式可以更好地管理汇编代码与 C 代码的分离，同时保持兼容性和可维护性。